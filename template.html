<!DOCTYPE html>
<html>

<head>
    <title></title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;
        // Converts from degrees to radians.
        Math.radians = function (degrees) {
            return degrees * Math.PI / 180;
        };

        // Converts from radians to degrees.
        Math.degrees = function (radians) {
            return radians * 180 / Math.PI;
        };
    </script>
        <script id="shader-vs-light" type="x-shader/x-vertex">#version 300 es
            precision mediump float;
            
            layout (location = 0) in vec3 aPos;


            uniform UBO {
                mat4 projection;
                mat4 view;
                vec3 lightColor;
            };

            uniform mat4 model;
            
        
            void main()
            {
                
                gl_Position = projection * view * model * vec4(aPos, 1.0);
            }
           
           
    </script>
    
        <script id="shader-fs-light" type="x-shader/x-fragment">#version 300 es
            precision mediump float;
    
            out vec4 fragColor;

            uniform UBO {
                mat4 projection;
                mat4 view;
                vec3 lightColor;
            };
            void main()
            {
                fragColor = vec4(lightColor, 1.0);
            }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;
    
        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };
    
        uniform mat4 model;
       
        out vec3 normal;
        out vec3 fragPos;
    
        void main()
        {
            fragPos = vec3(model * vec4(aPos, 1.0));
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            mat3 normalM = mat3(transpose(inverse(model)));
            normal = normalM * aNormal;
        }
       
       
</script>

    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 fragColor;
        in vec3 normal;
        in vec3 fragPos;

        uniform float ambientStrength;//0.1
        uniform float specularStrength;//0.8

        uniform vec3 spotLightDirection;
        uniform float spotLightOpeningAngle;
        uniform vec3 spotLightPosition;

        uniform vec3 lightPos;
        uniform vec3 viewPos;
        uniform vec3 objectColor;

        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };

        void main()
        {
            vec3 norm = normalize(normal);

            // ambient
            vec3 ambient = ambientStrength * lightColor;

            // diffuse
            vec3 lightDir = normalize(lightPos - fragPos);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * lightColor;

            // specular
            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            vec3 specular = specularStrength * spec * lightColor;

            vec3 L = normalize(spotLightPosition - fragPos);
            float spotLight_fdir;
            float product = dot(-L, spotLightDirection);
            float cosine = cos(spotLightOpeningAngle);
            if (cosine < product){
                spotLight_fdir = pow((product- cosine)/(1.0 - cosine), 5.0);
            }
            else spotLight_fdir = 0.0;
            float spotLight_fdistance;

            vec3 result = (ambient + spotLight_fdir*(diffuse + specular)) * objectColor;
            fragColor = vec4(result, 1.0);
        }
</script>

</head>

<body>
    <canvas id="myCanvas" width="500 " height="500"></canvas>
    <script type="text/javascript">
        function clamp(num, min, max) {
            return num <= min 
                ? min 
                : num >= max 
                ? max 
                : num;
                
        }
        var gl = createContext("myCanvas");
        
        //=====================================================
        // ============== Creation geomtry cube ===============
        //=====================================================
        var VAO, VBO, VBO2, VBO3, VBO4, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        VBO4 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPos), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormal), gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoord), gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        // index attribute
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);
        // Unbind the VBO
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        // Unbind the VAO
        gl.bindVertexArray(null);


        var shaderProgram = new ShaderProgram( );
        shaderProgram.createVertexShader(
          document.getElementById( "shader-vs" ).text
        );
        shaderProgram.createFragmentShader(
          document.getElementById( "shader-fs" ).text
        );
        shaderProgram.compile( );
        shaderProgram.link( );

        shaderProgram.autocatching( );

        shaderProgram.createUniform("model");
        shaderProgram.createUniform("lightPos");
        shaderProgram.createUniform("viewPos");
        shaderProgram.createUniform("objectColor");
        shaderProgram.createUniform("ambientStrength");
        shaderProgram.createUniform("specularStrength");

        // Shaders para la luz
        var shaderProgramL = new ShaderProgram( );
        shaderProgramL.createVertexShader(
          document.getElementById( "shader-vs-light" ).text
        );
        shaderProgramL.createFragmentShader(
          document.getElementById( "shader-fs-light" ).text
        );
        shaderProgramL.compile( );
        shaderProgramL.link( );

        shaderProgramL.autocatching( );

        var uboBuffer = gl.createBuffer( );
        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);
        const blockIndex = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");

        //Get the size of block
        const blockSize = gl.getActiveUniformBlockParameter(
            shaderProgram.mCompiledShader,    
            blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE
        );
        //Assignar memoria nula al UBO
        gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);

        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);

        const uboVariablesNames = [ "projection", "view", "lightColor"];

        //Obtenemos los ids
        const uboVariablesIndices = gl.getUniformIndices(
            shaderProgram.mCompiledShader,
            uboVariablesNames
        );

        //Obtenemos los offsets
        const uboVariablesOffset = gl.getActiveUniforms(
            shaderProgram.mCompiledShader,
            uboVariablesIndices,
            gl.UNIFORM_OFFSET
        );

        const uboVariablesInfo = {};
        uboVariablesNames.forEach((name, index) => {
            uboVariablesInfo[ name ] = {
                index: uboVariablesIndices[ index ],
                offset: uboVariablesOffset[ index ]
            } 
        });
        let index;
        index = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgram.mCompiledShader, index, 0);

        index = gl.getUniformBlockIndex(shaderProgramL.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgramL.mCompiledShader, index, 0);

        // ***** CANVAS DATAS *****
        var canvas = document.getElementById('myCanvas');
        canvas.style.cursor = 'none';
        let rect = canvas.getBoundingClientRect();
      
        // OTHER VALUES
        var radius = 20.0; // in meter
        var sensibility = 0.5
        var cameraPosSpeed = sensibility; // in meter per tick
        var cameraRotSpeed = sensibility / 3; // in meter per tick
        var yaw = - 90.0; // in degrees
        var pitch = 0.0; // in degrees
        var lastMouseX = rect.x / 2; // middle of the canva x value
        var lastMouseY = rect.y / 2; // middle of the canva y value
        var firstMouse = true;
        // CAMERA POSITION VALUES
        var camPosX = 0.0;
        var camPosY = 0.0;
        var camPosZ = radius;
        // CAMERA UP VALUES
        var camUpX = 0.0;
        var camUpY = 1.0;
        var camUpZ = 0.0;
        // VECTORS OF LOOKAT MATRIX
        var cameraPos   = [ camPosX, camPosY, camPosZ ];
        var cameraFront = [ 0.0    , 0.0    , 0.0     ];
        var cameraUp    = [ camUpX , camUpY , camUpZ  ];

        // ***** LIGHT DATA *****
        var ambientStrength = 0.1;
        var specularStrength = 0.8;
        var objectColor = new Float32Array([1.0, 0.5, 0.5]);
        var lightColor = new Float32Array([1.0, 1.0, 1.0]);

        shaderProgram.createUniform("spotLightPosition");
        shaderProgram.createUniform("spotLightDirection");
        shaderProgram.createUniform("spotLightOpeningAngle");

        var spotLightPosition = new Float32Array([0,0,0]);
        var spotLightDirection = new Float32Array([0,0,0]);
        var spotLightOpeningAngle = Math.radians(30.0); 


        // ==========================================================
        // ==================== RENDER FUNC =========================
        // ==========================================================

        function renderFunc(time) {
            time *= 0.001; // to seconds

            gl.viewport(0, 0, rect.width, rect.height);
            gl.clearColor(0.0, 0.5, 0.5, 1.0);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            shaderProgram.bind();

            // ***** CAMERA MATRICES *****
            // PROJ MATRIX
            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

            // VIEW MATRIX
            var yawRadians = Math.radians(yaw);
            var pitchRadians = Math.radians(pitch);
            var cosYaw = Math.cos(yawRadians);
            var sinYaw = Math.sin(yawRadians);
            var cosPitch = Math.cos(pitchRadians);
            var sinPitch = Math.sin(pitchRadians);
           
            var direction = vec3.create();
            direction[0] = cosYaw * cosPitch;
            direction[1] = sinPitch;
            direction[2] = sinYaw * cosPitch;
            vec3.normalize(cameraFront, direction);

            var camPosFront = vec3.create();
            vec3.add(camPosFront, cameraPos, cameraFront);
           
            var view = mat4.create();

            mat4.lookAt(view, cameraPos, camPosFront, cameraUp);


            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["projection"].offset,
                proj,
                0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["view"].offset,
                view,
                0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["lightColor"].offset,
                lightColor,
                0
            )
            // ***** FIRST SQUARE *****
            // MODEL MATRIX
            var angle = time * 100.0;
            var model = mat4.create();
            mat4.translate(model, model, [0.0, 0.0, 0.0]);
            mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 1.0]);

            shaderProgram.setUniformMat4("model", model);
            shaderProgram.setUniform3f("viewPos", camPosX, camPosY, -camPosZ);
            shaderProgram.setUniform3f("objectColor", objectColor[0], objectColor[1],  objectColor[2]);

            // ***** LIGHT *****
            var lightPosX = 3.0;
            var lightPosY = 1.0;
            var lightPosZ = 10.0;
            var lightPos = [lightPosX, lightPosY, lightPosZ];
            shaderProgram.setUniform3f("lightPos", lightPosX, lightPosY, lightPosZ);
            shaderProgram.setUniform1f("ambientStrength", ambientStrength);
            shaderProgram.setUniform1f("specularStrength", specularStrength);

            shaderProgram.setUniform3f("spotLightDirection", spotLightDirection);
            shaderProgram.setUniform3f("spotLightPosition", spotLightPosition);
            shaderProgram.setUniform1f("spotLightOpeningAngle", spotLightOpeningAngle)
            
            // ***** DRAWING FIRST SHADERS ******
            gl.bindVertexArray(VAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            // ***** SECOND SQUARE (indicates light) *****
            shaderProgramL.bind();
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["projection"].offset,
                proj,
                0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                uboVariablesInfo["view"].offset,
                view,
                0
            )

            // MODEL MATRIX
            var modelLight = mat4.create();
            mat4.translate (modelLight, modelLight, lightPos);
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);
            mat4.rotate(modelLight, modelLight, Math.radians(angle), [-1.0, -0.5, -1.0]);

            shaderProgramL.setUniformMat4("model", modelLight);
          
            //***** DRAWING SECOND SHADERS ******
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            gl.bindVertexArray(null);
            requestAnimationFrame(renderFunc);
        }
        
        document.addEventListener('keydown', function (event) {
            /*
                https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg
                65 => A
                68 => D
                83 => S
                87 => W
                81 => Q
                69 => E
    
                camara
                37 => Flecha izq
                39 => Fecha drcha
                38 => Fecha arriba
                40 => Fecha abajo
    
            */
           if(event.shiftKey) {
                switch (event.keyCode) {
                    // ***** AMBIENT AND SPECULAR ***** 
                    case 49: // shift + 1
                        ambientStrength += 0.1;
                        ambientStrength = Math.min(ambientStrength, 1.0);
                        console.log("ambient strength=" + ambientStrength);
                        break;
                    case 50: // shift + 2
                        ambientStrength -= 0.1;
                        ambientStrength = Math.max(ambientStrength, 0.0);
                        console.log("ambient strength=" + ambientStrength);
                        break; 
                    case 51: // shift + 3
                        specularStrength += 0.1;
                        specularStrength = Math.min(specularStrength, 1.0);
                        console.log("specular strength=" + specularStrength);
                        break;
                    case 52: // shift + 4
                        specularStrength -= 0.1;
                        specularStrength = Math.max(specularStrength, 0.0);
                        console.log("specular strength=" + specularStrength);
                        break;
                    // ***** CUBE COLOR *****
                    case 53: // shift + 5
                        //amarillo
                        objectColor[0] = 0.8;
                        objectColor[1] = 0.8;
                        objectColor[2] = 0.0;
                        break;
                    case 54: // shift + 6
                        //rojo
                        objectColor[0] = 1.0;
                        objectColor[1] = 0.0;
                        objectColor[2] = 0.0;
                        break;
                    case 55: // shift + 7
                        //blanco
                        objectColor[0] = 1.0;
                        objectColor[1] = 1.0;
                        objectColor[2] = 1.0;
                        break;
                    // ***** CAMERA MOVEMENT *****
                    case 32 :
                        var cameraUpSpeed = [
                            cameraUp[0] * cameraPosSpeed,
                            cameraUp[1] * cameraPosSpeed,
                            cameraUp[2] * cameraPosSpeed,
                        ];
                        vec3.subtract(cameraPos, cameraPos, cameraUpSpeed )     
                        console.log(" new camera position ", cameraPos)
                        break;
                    default :
                        break;
                }
           }
           else {
                switch (event.keyCode) {
                    // ***** CAMERA MOVEMENT *****
                    case 87 : // W
                    case 90 : // Z
                    case 38 : // going up
                        var cameraFrontSpeed = [
                            cameraFront[0] * cameraPosSpeed,
                            cameraFront[1] * cameraPosSpeed,
                            cameraFront[2] * cameraPosSpeed,
                        ];
                        vec3.add(cameraPos, cameraPos, cameraFrontSpeed )     
                        console.log(" new camera position ", cameraPos)
                    
                        break;
                    case 83 : // S
                    case 40 : // going down
                        var cameraFrontSpeed = [
                            cameraFront[0] * cameraPosSpeed,
                            cameraFront[1] * cameraPosSpeed,
                            cameraFront[2] * cameraPosSpeed,
                        ];
                        vec3.subtract(cameraPos, cameraPos, cameraFrontSpeed )      
                        console.log(" new camera position ", cameraPos)          
                        break;
                    case 65 : // A
                    case 81 : // Q
                    case 37 : // going left
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct[0] *= cameraPosSpeed;
                        crossProduct[1] *= cameraPosSpeed;
                        crossProduct[2] *= cameraPosSpeed;
                        vec3.subtract(cameraPos, cameraPos, crossProduct);
                        console.log(" new camera position ", cameraPos)          

                        break;
                    case 68 : // D
                    case 39 : // going right
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct[0] *= cameraPosSpeed;
                        crossProduct[1] *= cameraPosSpeed;
                        crossProduct[2] *= cameraPosSpeed;
                        vec3.add(cameraPos, cameraPos, crossProduct);
                        console.log(" new camera position ", cameraPos)          
                        break;
                    case 32 :
                    var cameraUpSpeed = [
                            cameraUp[0] * cameraPosSpeed,
                            cameraUp[1] * cameraPosSpeed,
                            cameraUp[2] * cameraPosSpeed,
                        ];
                        vec3.add(cameraPos, cameraPos, cameraUpSpeed )     
                        console.log(" new camera position ", cameraPos)
                        break;
                    // ***** CAMERA RESET *****
                    case 67 : // C
                        cameraPos[0] = camPosX;
                        cameraPos[1] = camPosY;
                        cameraPos[2] = camPosZ;

                        cameraUp[0] = camUpX;
                        cameraUp[1] = camUpY;
                        cameraUp[2] = camUpZ;

                        yaw = - 90.0;
                        pitch = 0.0;

                        break;
                    // ***** LIGHT COLOR *****
                    case 86: // V
                        //luz verde
                        lightColor[0] = 0.0;
                        lightColor[1] = 1.0;
                        lightColor[2] = 0.0;
                        break;
                    case 66: // B
                        //luz blanca
                        lightColor[0] = 1.0;
                        lightColor[1] = 1.0;
                        lightColor[2] = 1.0;
                        break;
                    default :
                        break;
                }
            }
        });
        
        document.addEventListener('mousemove', (event) => {
            const {
                clientX,
                clientY
            } = event;
            //console.log(clientX, clientY);

            let x = clientX /*- rect.left*/;
            let y = clientY /* - rect.top*/;
            //console.log(x, y);

            
            if (firstMouse)
            {
                lastMouseX = x;
                lastMouseY = y;
                firstMouse = false;
            }
            
        
            var xoffset = x - lastMouseX;
            var yoffset = lastMouseY - y; 
            lastMouseX = x;
            lastMouseY = y;

            xoffset *= cameraRotSpeed;
            yoffset *= cameraRotSpeed;

            yaw   += xoffset;
            pitch += yoffset;

            if(pitch > 89.0)
                pitch = 89.0;
            if(pitch < -89.0)
                pitch = -89.0;
            });


        renderFunc(0.0);

    </script>
</body>

