<!DOCTYPE html>
<html>
<head>
    <title>Practica1 Remi y Stefano </title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;
        Math.radians = function (degrees) {return degrees * Math.PI / 180;};        
        Math.degrees = function (radians) {return radians * 180 / Math.PI;};
        Math.clamp = function clamp(num, min, max) { return num <= min ? min : num >= max ? max : num;}
    </script>
    <script id="shader-vs-light" type="x-shader/x-vertex">#version 300 es
        precision mediump float;        
        layout (location = 0) in vec3 aPos;

        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 pointLightColor;
            vec3 pointLightPos;
            float pointLightStrength;
        };
        uniform mat4 model;
    
        void main(){gl_Position = projection * view * model * vec4(aPos, 1.0);}
    </script>
    <script id="shader-fs-light" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        //cubo pequeño luz
        out vec4 fragColor;

        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 pointLightColor;
            vec3 pointLightPos;
            float pointLightStrength;
        };
        void main(){fragColor = vec4(pointLightColor, pointLightStrength);}
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;
    
        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 pointLightColor;
            vec3 pointLightPos;
            float pointLightStrength;
        };
        uniform mat4 model;
       
        out vec3 normal;
        out vec3 fragPos;
    
        void main(){
            fragPos = vec3(model * vec4(aPos, 1.0));
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            mat3 normalM = mat3(transpose(inverse(model)));
            normal = normalM * aNormal;
        }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 fragColor;
        in vec3 normal;
        in vec3 fragPos;

        uniform float ambientStrength;
        uniform vec3 ambientColor;

        uniform vec3 diffuseColor;
        uniform float diffuseStrength;

        uniform float specularStrength;
        uniform vec3 specularColor;

        uniform vec3 spotLightPosition;
        uniform vec3 spotLightDirection;
        uniform float spotLightShadowAngle;
        uniform float spotLightCutOffAngle;
        float spotLightReach = 100.0; // the length of the spotLight
        uniform float spotLightStrength; // the intensity of the light
        uniform vec3 spotLightColor;

        uniform float dirLightStrength;
        uniform vec3 dirLightDirection;
        uniform vec3 dirLightColor;

        uniform vec3 viewPos;
        uniform vec3 objectColor;

        uniform float pointLightReach;

        uniform UBO {
            mat4 projection;
            mat4 view;
            vec3 pointLightColor;
            vec3 pointLightPos;
            float pointLightStrength;
        };
        void main(){
            vec3 norm = normalize(normal);

            vec3 ambient = ambientStrength * ambientColor;

            // diffuse
            vec3 lightDir = normalize(spotLightPosition - fragPos);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * diffuseColor * diffuseStrength;

            // specular
            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(lightDir, norm);

            vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * specularColor;


            // Spotlight
            float spotLight_fdir;
            vec3 L = normalize(spotLightPosition - fragPos);
            float angle =  dot(-L, spotLightDirection) / (length(-L) * length(spotLightDirection));
            float cosShadowAngle = cos(spotLightShadowAngle);
            float cosCutOffAngle = cos(spotLightCutOffAngle);
            if (cosCutOffAngle < angle) 
                if (cosShadowAngle < angle) spotLight_fdir = 1.0;
                else {
                    float t = pow((angle - cosCutOffAngle)/(cosShadowAngle - cosCutOffAngle), 0.5);
                    spotLight_fdir = pow(t, 2.0) * (3.0 - 2.0 * t);
                }
            else spotLight_fdir = 0.0;

            float distance = length(spotLightPosition - fragPos) / spotLightReach;
            float fwin = pow(max(1.0 - pow(distance / spotLightReach, 4.0), 0.0), 2.0);
            float spotLight_fdistance = fwin * pow(spotLightStrength, 2.0) / (pow(distance, 2.0) + 1.0);
            
            // Point light
            vec3 pointLightDir = pointLightPos - fragPos; 
            vec3 pointLight = max(dot(norm, normalize(pointLightDir)), 0.0) * pointLightColor * pointLightStrength;

            float attLinear = 1.0f, attExp = 1.0f;
            float pointLightDistanceIntensity = pointLightReach / (attLinear*length(pointLightDir)+attExp*length(pointLightDir)*length(pointLightDir));

            vec3 dirLight = dot(norm, normalize(-dirLightDirection)) * dirLightColor * dirLightStrength;

            vec3 result = (dirLight + ambient + pointLight + spotLightColor*spotLight_fdir*spotLight_fdistance + diffuse + specular )* objectColor;
            fragColor = vec4(result, 1.0);
        }
</script>
</head>
<body>
    <canvas id="myCanvas" width="600 " height="600"></canvas>
    https://jscolor.com/examples/
    <br>
    Ambient light <input id="ambientLightColorInput" value="rgba(255,255,255,0.15)" data-jscolor="{
        onChange: 'update(this, 1)',
    }" >
    <br>
    Diffuse light <input id="diffuseLightColorInput" value="rgba(255,255,255,0.8)" data-jscolor="{
        onChange: 'update(this, 2)',
    }">
    <br>
    Specular light <input id="specularLightColorInput" value="rgba(255,255,255,0.8)" data-jscolor="{
        onChange: 'update(this, 3)',
    }">
    <br>
    Spotlight <input id="spotLightColorInput" value="rgba(255,255,255,1)" data-jscolor="{
        onChange: 'update(this, 4)',
    }">
    <br>
    Directional light <input id="dirLightColorInput" value="rgba(255,255,255,1)" data-jscolor="{
        onChange: 'update(this, 5)',
    }">
    <br>
    Point light <input id="pointLightColorInput" value="rgba(255,255,255,1)" data-jscolor="{
        onChange: 'update(this, 6)',
    }">
    <br>
    TODO: ADD SLIDERS HERE FOR OTHER PARAMETERS
    <script src="jscolor.js"></script>
    <script type="text/javascript">    
        var gl = createContext("myCanvas");
        // acceder al input value de color: document.getElementById('textbox_id').value 
        //https://jscolor.com/examples/ ver cómo hacer con event
        //=====================================================
        // ============== Creation geomtry cube ===============
        //=====================================================
        var VAO, VBO, VBO2, VBO3, VBO4, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        VBO4 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPos), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormal), gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoord), gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        // index attribute
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);
        // Unbind the VBO
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        // Unbind the VAO
        gl.bindVertexArray(null);


        var shaderProgram = new ShaderProgram( );
        shaderProgram.createVertexShader(
          document.getElementById( "shader-vs" ).text
        );
        shaderProgram.createFragmentShader(
          document.getElementById( "shader-fs" ).text
        );
        shaderProgram.compile( );
        shaderProgram.link( );

        // Shaders para la luz
        var shaderProgramL = new ShaderProgram( );
        shaderProgramL.createVertexShader(
          document.getElementById( "shader-vs-light" ).text
        );
        shaderProgramL.createFragmentShader(
          document.getElementById( "shader-fs-light" ).text
        );
        shaderProgramL.compile( );
        shaderProgramL.link( );

        var uboBuffer = gl.createBuffer( );
        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);
        const blockIndex = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");

        //Get the size of block
        const blockSize = gl.getActiveUniformBlockParameter(
            shaderProgram.mCompiledShader,    
            blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE
        );
        //Assignar memoria nula al UBO
        gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);

        const uboVariablesNames = ["projection", "view", "pointLightColor", "pointLightPos", "pointLightStrength"];

        //Obtenemos los ids
        const uboVariablesIndices = gl.getUniformIndices(
            shaderProgram.mCompiledShader,
            uboVariablesNames
        );
        //Obtenemos los offsets
        const uboVariablesOffset = gl.getActiveUniforms(
            shaderProgram.mCompiledShader,
            uboVariablesIndices,
            gl.UNIFORM_OFFSET
        );

        const uboVariablesInfo = {};
        uboVariablesNames.forEach((name, index) => {
            uboVariablesInfo[ name ] = {
                index: uboVariablesIndices[ index ],
                offset: uboVariablesOffset[ index ]
            } 
        });
        let index = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgram.mCompiledShader, index, 0);

        index = gl.getUniformBlockIndex(shaderProgramL.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgramL.mCompiledShader, index, 0);

        // ***** CANVAS DATAS *****
        let canvas = document.getElementById('myCanvas');
        canvas.style.cursor = 'none';
        let rect = canvas.getBoundingClientRect();
      
        
        // OTHER VALUES
        var sensibility = 0.5
        var cameraPosSpeed = sensibility; // in meter per tick
        var cameraRotSpeed = sensibility / 3; // in meter per tick
        var yaw = - 90.0; // in degrees
        var pitch = 0.0; // in degrees
        var lastMouseX = rect.x / 2; // middle of the canva x value
        var lastMouseY = rect.y / 2; // middle of the canva y value
        var firstMouse = true;
        // CAMERA POSITION VALUES
        const initialCamPos = new Float32Array([0.0, 0.0, 20.0]);

        // CAMERA UP VALUES
        var initialCamUp = new Float32Array([0.0, 1.0, 0.0]);
        // VECTORS OF LOOKAT MATRIX
        var cameraPos   = initialCamPos
        var cameraFront = new Float32Array([ 0.0, 0.0, 0.0]);
        var cameraUp    = initialCamUp;

        // ***** LIGHT DATA *****

        // OTHER VALUES
        var ambientStrength = 0.15;

        var ambientColor = new Float32Array([1.0, 1.0, 1.0]);

        var diffuseStrength = 0.8;
        var diffuseColor = new Float32Array([1.0, 1.0, 1.0]);

        var specularStrength = 0.8;
        var specularColor = new Float32Array([1.0, 1.0, 1.0]);

        var shadowAngle = 0.0;
        var cutOffAngle = 9.0;
        var objectColor = new Float32Array([1.0, 0.5, 0.5]);
        var pointLightColor = new Float32Array([1.0, 1.0, 1.0]);

        var spotLightStrength = 1.0;
        var spotLightTarget = new Float32Array([0, 0, 0]);
        var spotLightPosition = cameraPos;
        var spotLightDirection = vec3.create();
        var spotLightShadowAngle = 0.0;
        var spotLightCutOffAngle = 0.0;        
        var spotLightColor = new Float32Array([1.0, 1.0, 1.0]);

        var dirLightStrength = 1.0;
        var dirLightColor = new Float32Array([1.0, 1.0, 1.0]);
        var dirLightDirection = new Float32Array([0.0, 0.0, 0.0]);

        // POINT LIGHT
        const pointLightOrbitingSpeed = 0.9;
        const pointLightOrbitRadius = 50;
        var pointLightPos = new Float32Array([0.0, 0.0, 0.0]);
        var pointLightColor = new Float32Array([1.0, 1.0, 1.0]);
        var pointLightStrength = new Float32Array([1.0]);
        var pointLightReach = 200.0;

        shaderProgram.autocatching();
        shaderProgramL.autocatching();

        jscolor.trigger('change');

        const cubePositions = [ 
                [ 0.0, 0.0, 0.0], 
                [ 4.0, 10.0, -30.0], 
                [-3.0, -4.4, -5.0], 
                [-7.6, -4.0, -24.6], 
                [ 4.8, -0.8, -7.0],
                [-4.4, 6.0, -14.0], 
                [ 2.6, -4.0, -5.0], 
                [ 3.0, 4.0, -5.0], 
                [ 3.0, 0.4, -3.0], 
                [-2.6, 2.0, -3.0],
            ];

        let colorStep = 1 / cubePositions.length;
        let randomColors = new Float32Array(cubePositions.length)
        randomColors = randomColors.map(() => Math.random())

        // ==========================================================
        // ==================== RENDER FUNC =========================
        // ==========================================================
        function renderFunc(time) {
            time *= 0.001; // time = seconds passed since loading page
            gl.viewport(0, 0, rect.width, rect.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            shaderProgram.bind();

            // ***** CAMERA MATRICES *****
            // PROJ MATRIX
            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

            // VIEW MATRIX
            var yawRadians = Math.radians(yaw);
            var pitchRadians = Math.radians(pitch);
            var cosYaw = Math.cos(yawRadians);
            var sinYaw = Math.sin(yawRadians);
            var cosPitch = Math.cos(pitchRadians);
            var sinPitch = Math.sin(pitchRadians);
           
            var direction = vec3.create();
            direction[0] = cosYaw * cosPitch;
            direction[1] = sinPitch;
            direction[2] = sinYaw * cosPitch;
            vec3.normalize(cameraFront, direction);

            var camPosFront = vec3.create();
            vec3.add(camPosFront, cameraPos, cameraFront);
           
            var view = mat4.create();

            mat4.lookAt(view, cameraPos, camPosFront, cameraUp);            

            // ***** SETTING UBO *****
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["projection"].offset,
                proj, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["view"].offset,
                view, 0
            )
            
            // ***** FIRST SQUARE *****
            shaderProgram.setUniform3f("viewPos", initialCamPos[0], initialCamPos[1], -initialCamPos[2]);

            // ***** LIGHT *****
            shaderProgram.setUniform1f("ambientStrength", ambientStrength);
            shaderProgram.setUniform3f("ambientColor", ...ambientColor)

            shaderProgram.setUniform1f("diffuseStrength", diffuseStrength);
            shaderProgram.setUniform3f("diffuseColor", ...diffuseColor)

            shaderProgram.setUniform1f("specularStrength", specularStrength);
            shaderProgram.setUniform3f("specularColor", ...specularColor)

            //***** POINT LIGHT ORBITING *****
            
            pointLightPos[0] = pointLightOrbitRadius * Math.cos(time * pointLightOrbitingSpeed);
            pointLightPos[1] = 0.0;
            pointLightPos[2] = pointLightOrbitRadius * Math.sin(time * pointLightOrbitingSpeed);

            // DIRECTIONAL LIGHT ORBITING
            const orbitingSpeed = 0.1;

            dirLightDirection[0] = Math.cos(time*orbitingSpeed);
            dirLightDirection[1] = Math.sin(time*orbitingSpeed);
            dirLightDirection[2] = 0;

            shaderProgram.setUniform3f("dirLightColor", ...dirLightColor)
            shaderProgram.setUniform1f("dirLightStrength", dirLightStrength);
            shaderProgram.setUniform3f("dirLightDirection", ...dirLightDirection);  

            spotLightPosition = cameraPos;
            spotLightDirection = cameraFront;
            // vec3.subtract(spotLightDirection, spotLightTarget, spotLightPosition);
            // vec3.normalize(spotLightDirection, spotLightDirection);
            spotLightShadowAngle = Math.radians(shadowAngle); 
            spotLightCutOffAngle = Math.radians(cutOffAngle); 

            shaderProgram.setUniform3f("spotLightColor", ...spotLightColor)
            shaderProgram.setUniform1f("spotLightStrength", spotLightStrength);
            shaderProgram.setUniform3f("spotLightDirection", ...spotLightDirection);
            shaderProgram.setUniform3f("spotLightPosition", ...spotLightPosition);
            shaderProgram.setUniform1f("spotLightShadowAngle", spotLightShadowAngle);
            shaderProgram.setUniform1f("spotLightCutOffAngle", spotLightCutOffAngle);
            
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["pointLightColor"].offset,
                pointLightColor, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["pointLightPos"].offset,
                pointLightPos, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["pointLightStrength"].offset,
                pointLightStrength, 0
            )
            shaderProgram.setUniform1f("pointLightReach", pointLightReach)
                                
            // ***** DRAWING FIRST SHADERS ******
            gl.bindVertexArray(VAO);


            for(let i = 0; i < cubePositions.length; i ++)
            {

                // MODEL MATRIX
                const angle = (i + 1.0) / 3.0 *  time  * 100.0;   
                let model = mat4.create();
                mat4.translate(model, model, cubePositions[i]);
                mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 1.0]);
                shaderProgram.setUniformMat4("model", model);
                // CUBE COLOR
                var cubeColor = new Float32Array([colorStep * i, randomColors[i] , 1 - colorStep * i]);
                shaderProgram.setUniform3f("objectColor", ...cubeColor);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);
            }

            // ***** LIGHT SQUARES *****
            shaderProgramL.bind();

            // MODEL MATRIX
            let modelLight = mat4.create();
            mat4.translate (modelLight, modelLight, pointLightPos);
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);
            mat4.rotate(modelLight, modelLight, Math.radians(time * 100.0), [-1.0, -0.5, -1.0]);

            shaderProgramL.setUniformMat4("model", modelLight);
          
            //***** DRAWING  ******
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            gl.bindVertexArray(null);
            requestAnimationFrame(renderFunc);
        }

        function update(picker, type) {
            switch (type){
                case 1:
                    ambientColor[0] = picker.channel('R')/255
                    ambientColor[1] = picker.channel('G')/255
                    ambientColor[2] = picker.channel('B')/255
                    ambientStrength = picker.channel('A')
                break;
                case 2:
                    diffuseColor[0] = picker.channel('R')/255
                    diffuseColor[1] = picker.channel('G')/255
                    diffuseColor[2] = picker.channel('B')/255
                    diffuseStrength = picker.channel('A')
                break;
                case 3:
                    specularColor[0] = picker.channel('R')/255
                    specularColor[1] = picker.channel('G')/255
                    specularColor[2] = picker.channel('B')/255
                    specularStrength = picker.channel('A')
                break;
                case 4:
                    spotLightColor[0] = picker.channel('R')/255
                    spotLightColor[1] = picker.channel('G')/255
                    spotLightColor[2] = picker.channel('B')/255
                    spotLightStrength = picker.channel('A')
                break;
                case 5:
                    dirLightColor[0] = picker.channel('R')/255
                    dirLightColor[1] = picker.channel('G')/255
                    dirLightColor[2] = picker.channel('B')/255
                    dirLightStrength = picker.channel('A')
                break;
                case 6:
                    pointLightColor[0] = picker.channel('R')/255
                    pointLightColor[1] = picker.channel('G')/255
                    pointLightColor[2] = picker.channel('B')/255
                    pointLightStrength[0] = picker.channel('A')
                break;
                default: console.error("type of light's color to update not handled")
            }
        }
        
        document.addEventListener('keydown', function (event) {
            /*
                https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg
    
            */
           if(event.shiftKey) {
                switch (event.keyCode) {
                    // ***** AMBIENT AND SPECULAR ***** 
                  
                    // ***** CUBE COLOR *****
                    case 53: // shift + 5
                        //amarillo
                        objectColor[0] = 0.8;
                        objectColor[1] = 0.8;
                        objectColor[2] = 0.0;
                        break;
                    case 54: // shift + 6
                        //rojo
                        objectColor[0] = 1.0;
                        objectColor[1] = 0.0;
                        objectColor[2] = 0.0;
                        break;
                    case 55: // shift + 7
                        //blanco
                        objectColor.fill(1.0)
                        break;
                    // ***** CAMERA MOVEMENT *****
                    // GOING DOWN
                    case 32 : // shift + space
                        vec3.subtract(cameraPos, cameraPos, cameraUp.map(x => x * cameraPosSpeed) )     
                        console.log("camera pos: ", cameraPos)
                        break;

                    // ***** LIGHT OPENING *****
                    case 80 : // P
                        shadowAngle += 2.0;
                        shadowAngle = Math.min(shadowAngle, cutOffAngle);
                        
                        console.log("shadowAngle :",shadowAngle);

                        break;
                    case 77 : // M
                        shadowAngle -= 2.0;
                        shadowAngle = Math.max(shadowAngle, 0.0);

                        console.log("shadowAngle :", shadowAngle);
                        break;
                    default :
                        break;
                }
           }
           // ***** MOVING LIGHT *****
           else if (event.altKey & event.ctrlKey) { // alt and ctrl to avoid ctrl + s and alt + d (shortcuts of firefox)

                switch (event.keyCode) {
                    // GOING FORWARD
                    case 87 : // W
                    case 90 : // Z
                    case 38 :// arrow up
                        vec3.add(lightPos, lightPos, cameraFront.map(x => x*cameraPosSpeed))     
                        //console.log(" new light position ", lightPos)
                    break;
                    // GOING BACKWARD
                    case 83 : // S
                    case 40 :// arrow down
                        vec3.subtract(lightPos, lightPos, cameraFront.map(x => x*cameraPosSpeed))     
                        //console.log(" new light position ", lightPos)
                    break;
                    // GOING LEFT
                    case 65 : // A
                    case 81 : // Q
                    case 37 : // arrow left
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x*cameraPosSpeed);
                        vec3.subtract(lightPos, lightPos, crossProduct);
                        //console.log(" new light position ", lightPos)
                        break;
                    // GOING RIGHT
                    case 68 : // D
                    case 39 : // arrow right
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x*cameraPosSpeed);
                        vec3.add(lightPos, lightPos, crossProduct);
                        //console.log(" new light position ", lightPos)
                        break;
                    // GOING UP
                    case 32 : // space
                        break;
                    // RESET
                    case 67 : // C
                        lightPos = startingLightPos
                        break; 
                    default :
                        break;
                }
           }
           else {
                switch (event.keyCode) {
                    // ***** CAMERA MOVEMENT *****
                    // GOING FORWARD
                    case 87: // W
                    case 90: // Z
                    case 38: // arrow up
                        vec3.add(cameraPos, cameraPos, cameraFront.map(x => x * cameraPosSpeed));  
                    break;
                    // GOING BACKWARD
                    case 83 : // S
                    case 40 : // arrow down
                        vec3.subtract(cameraPos, cameraPos, cameraFront.map(x => x * cameraPosSpeed));  
                        break;
                    // GOING LEFT
                    case 65 : // A
                    case 81 : // Q
                    case 37 : // arrow left
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x * cameraPosSpeed);
                        vec3.subtract(cameraPos, cameraPos, crossProduct);
                        break;
                    // GOING RIGHT
                    case 68 : // D
                    case 39 : // arrow right
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x * cameraPosSpeed);
                        vec3.add(cameraPos, cameraPos, crossProduct);
                        break;
                    // GOING UP
                    case 32 : // space
                        
                        vec3.add(cameraPos, cameraPos, cameraUp.map(x => x * cameraPosSpeed))     
                        break;
                    // ***** CAMERA RESET *****
                    case 67 : // C
                        cameraPos = initialCamPos;
                        cameraUp = initialCamUp;

                        yaw = -90.0;
                        pitch = 0.0;

                        break;

                    // ***** SPOTLIGHT OPENING *****
                    case 80 : // P
                        cutOffAngle += 2.0;
                        cutOffAngle = Math.min(180.0, cutOffAngle);
                        console.log("cutOffAngle :",cutOffAngle);

                        break;
                    case 77 : // M
                        cutOffAngle -= 2.0;
                        cutOffAngle = Math.max(shadowAngle, cutOffAngle);
                        console.log("cutOffAngle :", cutOffAngle);
                        break;
                    default :
                        break;
                }
            }
        });
        
        document.addEventListener('mousemove', (event) => {
            const {clientX, clientY} = event;
            const x = clientX;
            const y = clientY;
            
            if (firstMouse){
                lastMouseX = x;
                lastMouseY = y;
                firstMouse = false;
            }
            const xoffset = (x - lastMouseX)*cameraRotSpeed;
            const yoffset = (lastMouseY - y)*cameraRotSpeed; 
            lastMouseX = x;
            lastMouseY = y;

            yaw   += xoffset;
            pitch += yoffset;

            pitch = Math.clamp(pitch, -89.0, 89.0)
        })

        renderFunc(0.0);

    </script>
</body>
