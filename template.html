<!DOCTYPE html>
<html>

<head>
    <title>Práctica 1 Remi [apellido] y Stefano Tomasini</title>
    <script type="text/javascript" src="auxiliars.js"></script>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;
        Math.radians = function (degrees) {return degrees * Math.PI / 180;};        
        Math.degrees = function (radians) {return radians * 180 / Math.PI;};
        Math.clamp = function clamp(num, min, max) { return num <= min ? min : num >= max ? max : num;}
    </script>
    <script id="shader-vs-light" type="x-shader/x-vertex">#version 300 es
        precision mediump float;        
        layout (location = 0) in vec3 aPos;

        uniform UBO {
            vec3 dirLightDirection;
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };
        uniform mat4 model;
    
        void main(){gl_Position = projection * view * model * vec4(aPos, 1.0);}
    </script>
    <script id="shader-fs-light" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 fragColor;

        uniform UBO {
            vec3 dirLightDirection;
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };
        void main(){fragColor = vec4(lightColor, 1.0);}
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;
        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;
    
        uniform UBO {
            vec3 dirLightDirection;
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };
        uniform mat4 model;
       
        out vec3 normal;
        out vec3 fragPos;
    
        void main(){
            fragPos = vec3(model * vec4(aPos, 1.0));
            gl_Position = projection * view * model * vec4(aPos, 1.0);
            mat3 normalM = mat3(transpose(inverse(model)));
            normal = normalM * aNormal;
        }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 fragColor;
        in vec3 normal;
        in vec3 fragPos;

        uniform float ambientStrength;//0.1
        uniform float specularStrength;//0.8

        uniform vec3 spotLightPosition;
        uniform vec3 spotLightDirection;
        uniform float spotLightShadowAngle;
        uniform float spotLightCutOffAngle;
        float spotLightStrenght = 100.0; // the length of the spotLight
        float spotLightIntensity = 1.0; // the intensity of the light

        uniform vec3 viewPos;
        uniform vec3 objectColor;

        uniform UBO {
            vec3 dirLightDirection;//asignarle un color?
            mat4 projection;
            mat4 view;
            vec3 lightColor;
        };
        void main(){
            vec3 norm = normalize(normal);

            vec3 ambient = ambientStrength * lightColor;

            // diffuse
            vec3 lightDir = normalize(spotLightPosition - fragPos);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * lightColor;

            // specular
            vec3 viewDir = normalize(viewPos - fragPos);
            //vec3 reflectDir = reflect(lightDir, norm);
            vec3 reflectDir = 2.0 * (lightDir * norm) * norm - lightDir;

            vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * lightColor;

            // Luz focal
            float spotLight_fdir;
            vec3 L = normalize(spotLightPosition - fragPos);
            float angle =  dot(-L, spotLightDirection) / (length(-L) * length(spotLightDirection));
            float cosShadowAngle = cos(spotLightShadowAngle);
            float cosCutOffAngle = cos(spotLightCutOffAngle);

            if (cosCutOffAngle < angle) 
                if (cosShadowAngle < angle) spotLight_fdir = 1.0;
                else {
                    float t = pow((angle - cosCutOffAngle)/(cosShadowAngle - cosCutOffAngle), 0.5);
                    spotLight_fdir = pow(t, 2.0) * (3.0 - 2.0 * t);
                }
            else spotLight_fdir = 0.0;
            

            float dirLight = dot(norm, normalize(-dirLightDirection));

            float distance = length(spotLightPosition - fragPos) / spotLightStrenght;
            float fwin = pow(max(1.0 - pow(distance / spotLightStrenght, 4.0), 0.0), 2.0);
            float spotLight_fdistance = fwin * pow(spotLightIntensity, 2.0) / (pow(distance, 2.0) + 1.0);

            vec3 result = (dirLight + ambient + spotLight_fdir * spotLight_fdistance * (diffuse + specular)) * objectColor;
            fragColor = vec4(result, 1.0);
        }
</script>
</head>
<body>
    <canvas id="myCanvas" width="600 " height="600"></canvas>
    <script src="jscolor.js"></script>
https://jscolor.com/examples/
    <br>
    Ambient light color: <input id="ambientLightColorInput" value="#3399FF80" data-jscolor="{}">
    <br>
    Specular light color: <input id="specularLightColorInput" value="#3399FF80" data-jscolor="{}">
    <br>
    Spotlight color: <input id="spotLightColorInput" value="#3399FF80" data-jscolor="{}">
    <br>
    Directional light color: <input id="dirLightColorInput" value="#3399FF80" data-jscolor="{}">

    <script type="text/javascript">    
        var gl = createContext("myCanvas");
        // acceder al input value de color: document.getElementById('textbox_id').value 
        //https://jscolor.com/examples/ ver cómo hacer con event
        //=====================================================
        // ============== Creation geomtry cube ===============
        //=====================================================
        var VAO, VBO, VBO2, VBO3, VBO4, EBO;
        VAO = gl.createVertexArray();
        VBO = gl.createBuffer();
        VBO2 = gl.createBuffer();
        VBO3 = gl.createBuffer();
        VBO4 = gl.createBuffer();
        EBO = gl.createBuffer();
        gl.bindVertexArray(VAO);
        // position attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexPos), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        // normal attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO2);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormal), gl.STATIC_DRAW);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(1);
        // texCoord attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, VBO3);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoord), gl.STATIC_DRAW);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(2);
        // index attribute
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);
        // Unbind the VBO
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        // Unbind the VAO
        gl.bindVertexArray(null);


        var shaderProgram = new ShaderProgram( );
        shaderProgram.createVertexShader(
          document.getElementById( "shader-vs" ).text
        );
        shaderProgram.createFragmentShader(
          document.getElementById( "shader-fs" ).text
        );
        shaderProgram.compile( );
        shaderProgram.link( );

        // Shaders para la luz
        var shaderProgramL = new ShaderProgram( );
        shaderProgramL.createVertexShader(
          document.getElementById( "shader-vs-light" ).text
        );
        shaderProgramL.createFragmentShader(
          document.getElementById( "shader-fs-light" ).text
        );
        shaderProgramL.compile( );
        shaderProgramL.link( );

        var uboBuffer = gl.createBuffer( );
        gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer);
        const blockIndex = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");

        //Get the size of block
        const blockSize = gl.getActiveUniformBlockParameter(
            shaderProgram.mCompiledShader,    
            blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE
        );
        //Assignar memoria nula al UBO
        gl.bufferData(gl.UNIFORM_BUFFER, blockSize, gl.DYNAMIC_DRAW);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, uboBuffer);

        const uboVariablesNames = ["dirLightDirection", "projection", "view", "lightColor"];

        //Obtenemos los ids
        const uboVariablesIndices = gl.getUniformIndices(
            shaderProgram.mCompiledShader,
            uboVariablesNames
        );
        //Obtenemos los offsets
        const uboVariablesOffset = gl.getActiveUniforms(
            shaderProgram.mCompiledShader,
            uboVariablesIndices,
            gl.UNIFORM_OFFSET
        );

        const uboVariablesInfo = {};
        uboVariablesNames.forEach((name, index) => {
            uboVariablesInfo[ name ] = {
                index: uboVariablesIndices[ index ],
                offset: uboVariablesOffset[ index ]
            } 
        });
        let index = gl.getUniformBlockIndex(shaderProgram.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgram.mCompiledShader, index, 0);

        index = gl.getUniformBlockIndex(shaderProgramL.mCompiledShader, "UBO");
        gl.uniformBlockBinding(shaderProgramL.mCompiledShader, index, 0);

        // ***** CANVAS DATAS *****
        let canvas = document.getElementById('myCanvas');
        canvas.style.cursor = 'none';
        let rect = canvas.getBoundingClientRect();
      
        // OTHER VALUES
        var radius = 20.0; // in meter
        var sensibility = 0.5
        var cameraPosSpeed = sensibility; // in meter per tick
        var cameraRotSpeed = sensibility / 3; // in meter per tick
        var yaw = - 90.0; // in degrees
        var pitch = 0.0; // in degrees
        var lastMouseX = rect.x / 2; // middle of the canva x value
        var lastMouseY = rect.y / 2; // middle of the canva y value
        var firstMouse = true;
        // CAMERA POSITION VALUES
        const initialCamPos = new Float32Array([0.0, 0.0, radius]);

        // CAMERA UP VALUES
        var initialCamUp = new Float32Array([0.0, 1.0, 0.0]);
        // VECTORS OF LOOKAT MATRIX
        var cameraPos   = initialCamPos
        var cameraFront = new Float32Array([ 0.0    , 0.0    , 0.0     ]);
        var cameraUp    = initialCamUp;

        // ***** LIGHT DATA *****
        //  BEGIN POSITION
        var lightPos = new Float32Array([3.0, 1.0, 10.0]);

        // OTHER VALUES
        var ambientStrength = 0.15;
        var specularStrength = 0.8;
        var shadowAngle = 0.0;
        var cutOffAngle = 9.0;
        var objectColor = new Float32Array([1.0, 0.5, 0.5]);
        var lightColor = new Float32Array([1.0, 1.0, 1.0]);
        var spotLightTarget = new Float32Array([0,0,0]);

        var spotLightPosition = lightPos;
        var spotLightDirection = vec3.create();
        var spotLightShadowAngle = 0.0;
        var spotLightCutOffAngle = 0.0;        

        var dirLightDirection = new Float32Array([0.0, 0.0, 0.0])

        shaderProgram.autocatching( );
        shaderProgramL.autocatching( );

        // ==========================================================
        // ==================== RENDER FUNC =========================
        // ==========================================================
        function renderFunc(time) {
            time *= 0.001; // time = seconds passed since loading page
            gl.viewport(0, 0, rect.width, rect.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            shaderProgram.bind();

            // ***** CAMERA MATRICES *****
            // PROJ MATRIX
            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);

            // VIEW MATRIX
            var yawRadians = Math.radians(yaw);
            var pitchRadians = Math.radians(pitch);
            var cosYaw = Math.cos(yawRadians);
            var sinYaw = Math.sin(yawRadians);
            var cosPitch = Math.cos(pitchRadians);
            var sinPitch = Math.sin(pitchRadians);
           
            var direction = vec3.create();
            direction[0] = cosYaw * cosPitch;
            direction[1] = sinPitch;
            direction[2] = sinYaw * cosPitch;
            vec3.normalize(cameraFront, direction);

            var camPosFront = vec3.create();
            vec3.add(camPosFront, cameraPos, cameraFront);
           
            var view = mat4.create();

            mat4.lookAt(view, cameraPos, camPosFront, cameraUp);

            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["dirLightDirection"].offset,
                dirLightDirection, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["projection"].offset,
                proj, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["view"].offset,
                view, 0
            )
            gl.bufferSubData(
                gl.UNIFORM_BUFFER, uboVariablesInfo["lightColor"].offset,
                lightColor, 0
            )
            
            // ***** FIRST SQUARE *****
            shaderProgram.setUniform3f("viewPos", initialCamPos[0], initialCamPos[1], -initialCamPos[2]);

            // ***** LIGHT *****
            spotLightPosition = lightPos;
            vec3.subtract(spotLightDirection, spotLightTarget, spotLightPosition);
            vec3.normalize(spotLightDirection, spotLightDirection);
            spotLightShadowAngle = Math.radians(shadowAngle); 
            spotLightCutOffAngle = Math.radians(cutOffAngle); 

            shaderProgram.setUniform3f("lightPos", ...lightPos);
            shaderProgram.setUniform1f("ambientStrength", ambientStrength);
            shaderProgram.setUniform1f("specularStrength", specularStrength);

            //directional light orbiting
            const orbitingSpeed = 0.9;

            dirLightDirection[0] = Math.cos(time*orbitingSpeed);
            dirLightDirection[1] = Math.sin(time*orbitingSpeed);
            dirLightDirection[2] = 0;

            shaderProgram.setUniform3f("dirLightDirection", ...dirLightDirection);

            shaderProgram.setUniform3f("spotLightDirection", ...spotLightDirection);
            shaderProgram.setUniform3f("spotLightPosition", ...spotLightPosition);
            shaderProgram.setUniform1f("spotLightShadowAngle", spotLightShadowAngle);
            shaderProgram.setUniform1f("spotLightCutOffAngle", spotLightCutOffAngle);
            
            // ***** DRAWING FIRST SHADERS ******
            gl.bindVertexArray(VAO);

            const cubePositions = [ 
                [ 0.0, 0.0, 0.0], 
                [ 4.0, 10.0, -30.0], 
                [-3.0, -4.4, -5.0], 
                [-7.6, -4.0, -24.6], 
                [ 4.8, -0.8, -7.0],
                [-4.4, 6.0, -14.0], 
                [ 2.6, -4.0, -5.0], 
                [ 3.0, 4.0, -5.0], 
                [ 3.0, 0.4, -3.0], 
                [-2.6, 2.0, -3.0],
             ];
             let colorStep = 1 / cubePositions.length;

            for(let i = 0; i < cubePositions.length; i ++)
            {

                // MODEL MATRIX
                const angle = (i + 1.0) / 3.0 *  time  * 100.0;   
                let model = mat4.create();
                mat4.translate(model, model, cubePositions[i]);
                mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 1.0]);
                shaderProgram.setUniformMat4("model", model);
                // CUBE COLOR
                var cubeColor = new Float32Array([colorStep * i, 0 , 1 - colorStep * i]);
                shaderProgram.setUniform3f("objectColor", ...cubeColor);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);
            }
            // ***** SECOND SQUARE (indicates light) *****
            shaderProgramL.bind();

            // MODEL MATRIX
            let modelLight = mat4.create();
            mat4.translate (modelLight, modelLight, lightPos);
            mat4.scale(modelLight, modelLight, [0.25, 0.25, 0.25]);
            mat4.rotate(modelLight, modelLight, Math.radians(angle), [-1.0, -0.5, -1.0]);

            shaderProgramL.setUniformMat4("model", modelLight);
          
            //***** DRAWING SECOND SHADERS ******
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_INT, 0);

            gl.bindVertexArray(null);
            requestAnimationFrame(renderFunc);
        }
        
        document.addEventListener('keydown', function (event) {
            /*
                https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg
    
            */
           if(event.shiftKey) {
                switch (event.keyCode) {
                    // ***** AMBIENT AND SPECULAR ***** 
                    case 49: // shift + 1
                        ambientStrength += 0.1;
                        ambientStrength = Math.min(ambientStrength, 1.0);
                        console.log("ambient strength=" + ambientStrength);
                        break;
                    case 50: // shift + 2
                        ambientStrength -= 0.1;
                        ambientStrength = Math.max(ambientStrength, 0.0);
                        console.log("ambient strength=" + ambientStrength);
                        break; 
                    case 51: // shift + 3
                        specularStrength += 0.1;
                        specularStrength = Math.min(specularStrength, 1.0);
                        console.log("specular strength=" + specularStrength);
                        break;
                    case 52: // shift + 4
                        specularStrength -= 0.1;
                        specularStrength = Math.max(specularStrength, 0.0);
                        console.log("specular strength=" + specularStrength);
                        break;
                    // ***** CUBE COLOR *****
                    case 53: // shift + 5
                        //amarillo
                        objectColor[0] = 0.8;
                        objectColor[1] = 0.8;
                        objectColor[2] = 0.0;
                        break;
                    case 54: // shift + 6
                        //rojo
                        objectColor[0] = 1.0;
                        objectColor[1] = 0.0;
                        objectColor[2] = 0.0;
                        break;
                    case 55: // shift + 7
                        //blanco
                        objectColor.fill(1.0)
                        break;
                    // ***** CAMERA MOVEMENT *****
                    // GOING DOWN
                    case 32 : // shift + space
                        vec3.subtract(cameraPos, cameraPos, cameraUp.map(x => x * cameraPosSpeed) )     
                        console.log("camera pos: ", cameraPos)
                        break;

                    // ***** LIGHT OPENING *****
                    case 80 : // P
                        shadowAngle += 2.0;
                        shadowAngle = Math.min(shadowAngle, cutOffAngle);
                        
                        console.log("shadowAngle :",shadowAngle);

                        break;
                    case 77 : // M
                        shadowAngle -= 2.0;
                        shadowAngle = Math.max(shadowAngle, 0.0);

                        console.log("shadowAngle :", shadowAngle);
                        break;
                    default :
                        break;
                }
           }
           // ***** MOVING LIGHT *****
           else if (event.altKey & event.ctrlKey) { // alt and ctrl to avoid ctrl + s and alt + d (shortcuts of firefox)

                switch (event.keyCode) {
                    // GOING FORWARD
                    case 87 : // W
                    case 90 : // Z
                    case 38 :// arrow up
                        vec3.add(lightPos, lightPos, cameraFront.map(x => x*cameraPosSpeed))     
                        //console.log(" new light position ", lightPos)
                    break;
                    // GOING BACKWARD
                    case 83 : // S
                    case 40 :// arrow down
                        vec3.subtract(lightPos, lightPos, cameraFront.map(x => x*cameraPosSpeed))     
                        //console.log(" new light position ", lightPos)
                    break;
                    // GOING LEFT
                    case 65 : // A
                    case 81 : // Q
                    case 37 : // arrow left
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x*cameraPosSpeed);
                        vec3.subtract(lightPos, lightPos, crossProduct);
                        //console.log(" new light position ", lightPos)
                        break;
                    // GOING RIGHT
                    case 68 : // D
                    case 39 : // arrow right
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x*cameraPosSpeed);
                        vec3.add(lightPos, lightPos, crossProduct);
                        //console.log(" new light position ", lightPos)
                        break;
                    // GOING UP
                    case 32 : // space
                        break;
                    // RESET
                    case 67 : // C
                        lightPos = startingLightPos
                        break; 
                    default :
                        break;
                }
           }
           else {
                switch (event.keyCode) {
                    // ***** CAMERA MOVEMENT *****
                    // GOING FORWARD
                    case 87: // W
                    case 90: // Z
                    case 38: // arrow up
                        vec3.add(cameraPos, cameraPos, cameraFront.map(x => x * cameraPosSpeed));  
                    break;
                    // GOING BACKWARD
                    case 83 : // S
                    case 40 : // arrow down
                        vec3.subtract(cameraPos, cameraPos, cameraFront.map(x => x * cameraPosSpeed));  
                        break;
                    // GOING LEFT
                    case 65 : // A
                    case 81 : // Q
                    case 37 : // arrow left
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x * cameraPosSpeed);
                        vec3.subtract(cameraPos, cameraPos, crossProduct);
                        break;
                    // GOING RIGHT
                    case 68 : // D
                    case 39 : // arrow right
                        var crossProduct = vec3.create();
                        vec3.cross(crossProduct, cameraFront, cameraUp);
                        vec3.normalize(crossProduct, crossProduct);
                        crossProduct = crossProduct.map(x => x * cameraPosSpeed);
                        vec3.add(cameraPos, cameraPos, crossProduct);
                        break;
                    // GOING UP
                    case 32 : // space
                        
                        vec3.add(cameraPos, cameraPos, cameraUp.map(x => x * cameraPosSpeed))     
                        break;
                    // ***** CAMERA RESET *****
                    case 67 : // C
                        cameraPos = initialCamPos;
                        cameraUp = initialCamUp;

                        yaw = -90.0;
                        pitch = 0.0;

                        break;
                    // ***** LIGHT COLOR ***** THIS SECTION TO BE REMOVED (WILL BE REPLACED BY COLOR PICKER EVENTS)
                    case 86: // V
                        //luz verde
                        lightColor[0] = 0.0;
                        lightColor[1] = 1.0;
                        lightColor[2] = 0.0;
                        break;
                    case 66: // B
                        //white light
                        lightColor.fill(1.0);
                        break;
                    // ^^^^^ LIGHT COLOR ^^^^^ THIS SECTION TO BE REMOVED
                    // ***** SPOTLIGHT OPENING *****
                    case 80 : // P
                        cutOffAngle += 2.0;
                        cutOffAngle = Math.min(180.0, cutOffAngle);
                        console.log("cutOffAngle :",cutOffAngle);

                        break;
                    case 77 : // M
                        cutOffAngle -= 2.0;
                        cutOffAngle = Math.max(shadowAngle, cutOffAngle);
                        console.log("cutOffAngle :", cutOffAngle);
                        break;
                    default :
                        break;
                }
            }
        });
        
        document.addEventListener('mousemove', (event) => {
            const {clientX, clientY} = event;
            const x = clientX;
            const y = clientY;
            
            if (firstMouse){
                lastMouseX = x;
                lastMouseY = y;
                firstMouse = false;
            }
            const xoffset = (x - lastMouseX)*cameraRotSpeed;
            const yoffset = (lastMouseY - y)*cameraRotSpeed; 
            lastMouseX = x;
            lastMouseY = y;

            yaw   += xoffset;
            pitch += yoffset;

            pitch = Math.clamp(pitch, -89.0, 89.0)}
            )

        renderFunc(0.0);

    </script>
</body>

